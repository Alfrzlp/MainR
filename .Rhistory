iris <- iris %>% janitor::clean_names()
hasil <- decision_tree(
species ~ .,
data = iris,
metric_func = "gini impurity",
max_depth = 3,
min_n = 20,
min_ig = 1e-3
)
N <- nrow(iris)
hasil <- decision_tree(
species ~ .,
data = iris,
metric_func = "gini impurity",
max_depth = 3,
min_n = 20,
min_ig = 1e-3
)
generate_node <- function(dat, depth = 0, max_depth, min_n, min_ig, metric_func, is_regression) {
y <- dat[, 1]
x <- dat[, -1]
mode_y <- names(which.max(table(y)))
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (!is_regression & length(unique(y)) == 1) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = mode_y
))
}
if (depth <= max_depth) {
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (all(is.na(res[1, ]))) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
idx <- .get_idsplit(dat, res)
if (res$best_ig > min_ig) {
if (sum(idx) >= min_n & length(idx) - sum(idx) >= min_n) {
if (depth + 1 > max_depth) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
n_t <- nrow(dat)
output <- list(
depth = depth,
pos = ifelse(depth == 0, "root", "decision"),
variabel = res$var,
is_numeric = res$is_numeric,
split = res$best_split,
n = n_t,
ig = res$best_ig,
right = generate_node(dat[idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression),
left = generate_node(dat[!idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression)
# fi = (n_t/N) * (res$best_ig - nrow(dat[idx, ])/n_t * 0.444 - nrow(dat[!idx, ])/n_t * 0)
)
output$fi <- (n_t/N) * (res$best_ig - nrow(dat[idx, ])/n_t * output$right$ig - nrow(dat[!idx, ])/n_t * output$left$ig)
return(output)
}
}
} else {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
# ----
}
}
}
}
hasil <- decision_tree(
species ~ .,
data = iris,
metric_func = "gini impurity",
max_depth = 3,
min_n = 20,
min_ig = 1e-3
)
hasil
str(hasil)
hasil_rpart <- rpart::rpart(species ~ ., data = iris, maxdepth = 3, minbucket = 20, minsplit = 40, cp = 1e-9)
hasil_rpart$variable.importance
names(iris)
names(iris[-5])
list(names(iris[-5]))
data.frame(name = c(), fi = c())
df_fi <- data.frame(name = c(), fi = c())
rbind(df_fi, c('a', 1))
df_fi <- data.frame(name = c(), fi = c())
rbind(df_fi, c('a', 1))
rbind(df_fi, c(name = 'a', fi = 1))
df_fi
df_fi <- data.frame(name = c(), fi = c())
rbind(df_fi, c(name = 'a', fi = 1))
rbind(df_fi, data.frame(name = 'a', fi = 1))
df_fi <- data.frame()
rbind(df_fi, data.frame(name = 'a', fi = 1))
df_fi <- data.frame()
generate_node <- function(dat, depth = 0, max_depth, min_n, min_ig, metric_func, is_regression) {
y <- dat[, 1]
x <- dat[, -1]
mode_y <- names(which.max(table(y)))
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (!is_regression & length(unique(y)) == 1) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = mode_y
))
}
if (depth <= max_depth) {
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (all(is.na(res[1, ]))) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
idx <- .get_idsplit(dat, res)
if (res$best_ig > min_ig) {
if (sum(idx) >= min_n & length(idx) - sum(idx) >= min_n) {
if (depth + 1 > max_depth) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
n_t <- nrow(dat)
output <- list(
depth = depth,
pos = ifelse(depth == 0, "root", "decision"),
variabel = res$var,
is_numeric = res$is_numeric,
split = res$best_split,
n = n_t,
ig = res$best_ig,
right = generate_node(dat[idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression),
left = generate_node(dat[!idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression)
# fi = (n_t/N) * (res$best_ig - nrow(dat[idx, ])/n_t * 0.444 - nrow(dat[!idx, ])/n_t * 0)
)
output$fi <- (n_t/N) * (res$best_ig - nrow(dat[idx, ])/n_t * output$right$ig - nrow(dat[!idx, ])/n_t * output$left$ig)
df_fi <<- rbind(df_fi, data.frame(name = res$var, fi = output$fi))
return(output)
}
}
} else {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
# ----
}
}
}
}
hasil <- decision_tree(
species ~ .,
data = iris,
metric_func = "gini impurity",
max_depth = 3,
min_n = 20,
min_ig = 1e-3
)
hasil
str(hasil)
print(hasil)
df_fi
hasil_rpart <- rpart::rpart(species ~ ., data = iris, maxdepth = 3, minbucket = 20, minsplit = 40, cp = 1e-9)
hasil_rpart$variable.importance
df_fi %>%
group_by(name) %>%
summarise_all(sum)
df_fi %>%
group_by(name) %>%
summarise_all(sum) %>%
mutate(norm_fi = fi/sum(fi))
df_fi <- data.frame()
generate_node <- function(dat, depth = 0, max_depth, min_n, min_ig, metric_func, is_regression) {
y <- dat[, 1]
x <- dat[, -1]
mode_y <- names(which.max(table(y)))
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (!is_regression & length(unique(y)) == 1) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = mode_y
))
}
if (depth <= max_depth) {
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (all(is.na(res[1, ]))) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
idx <- .get_idsplit(dat, res)
if (res$best_ig > min_ig) {
if (sum(idx) >= min_n & length(idx) - sum(idx) >= min_n) {
if (depth + 1 > max_depth) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
n_t <- nrow(dat)
output <- list(
depth = depth,
pos = ifelse(depth == 0, "root", "decision"),
variabel = res$var,
is_numeric = res$is_numeric,
split = res$best_split,
n = n_t,
ig = res$best_ig,
right = generate_node(dat[idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression),
left = generate_node(dat[!idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression)
)
fi <- (n_t/N) * (res$best_ig - nrow(dat[idx, ])/n_t * output$right$ig - nrow(dat[!idx, ])/n_t * output$left$ig)
df_fi <<- rbind(df_fi, data.frame(name = res$var, fi = fi))
return(output)
}
}
} else {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
# ----
}
}
}
}
hasil <- decision_tree(
species ~ .,
data = iris,
metric_func = "gini impurity",
max_depth = 3,
min_n = 20,
min_ig = 1e-3
)
hasil
str(hasil)
print(hasil)
predict(hasil, newdata = iris[, -5])
df_fi %>%
group_by(name) %>%
summarise_all(sum) %>%
mutate(norm_fi = fi/sum(fi))
df_fi <- data.frame(name = names(iris[-5]), fi = 0)
df_fi
df_fi['sepal_length', ]
df_fi$name == 'sepal_length'
df_fi[df_fi$name == 'sepal_length']
df_fi[df_fi$name == 'sepal_length', ]
df_fi['sepal_length', 'fi']
df_fi[df_fi$name == 'sepal_length', 2]
df_fi <- data.frame(name = names(iris[-5]), fi = 0)
df_fi
generate_node <- function(dat, depth = 0, max_depth, min_n, min_ig, metric_func, is_regression) {
y <- dat[, 1]
x <- dat[, -1]
mode_y <- names(which.max(table(y)))
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (!is_regression & length(unique(y)) == 1) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = mode_y
))
}
if (depth <= max_depth) {
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (all(is.na(res[1, ]))) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
idx <- .get_idsplit(dat, res)
if (res$best_ig > min_ig) {
if (sum(idx) >= min_n & length(idx) - sum(idx) >= min_n) {
if (depth + 1 > max_depth) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
n_t <- nrow(dat)
output <- list(
depth = depth,
pos = ifelse(depth == 0, "root", "decision"),
variabel = res$var,
is_numeric = res$is_numeric,
split = res$best_split,
n = n_t,
ig = res$best_ig,
right = generate_node(dat[idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression),
left = generate_node(dat[!idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression)
)
fi <- (n_t/N) * (res$best_ig - nrow(dat[idx, ])/n_t * output$right$ig - nrow(dat[!idx, ])/n_t * output$left$ig)
df_fi[df_fi$name == res$var, 2] <- df_fi[df_fi$name == res$var, 2] + fi
return(output)
}
}
} else {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
# ----
}
}
}
}
hasil <- decision_tree(
species ~ .,
data = iris,
metric_func = "gini impurity",
max_depth = 3,
min_n = 20,
min_ig = 1e-3
)
hasil
df_fi
generate_node <- function(dat, depth = 0, max_depth, min_n, min_ig, metric_func, is_regression) {
y <- dat[, 1]
x <- dat[, -1]
mode_y <- names(which.max(table(y)))
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (!is_regression & length(unique(y)) == 1) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = mode_y
))
}
if (depth <= max_depth) {
res <- .get_feature_split(y, x, func = metric_func, min_n = min_n)
if (all(is.na(res[1, ]))) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
idx <- .get_idsplit(dat, res)
if (res$best_ig > min_ig) {
if (sum(idx) >= min_n & length(idx) - sum(idx) >= min_n) {
if (depth + 1 > max_depth) {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
} else {
n_t <- nrow(dat)
output <- list(
depth = depth,
pos = ifelse(depth == 0, "root", "decision"),
variabel = res$var,
is_numeric = res$is_numeric,
split = res$best_split,
n = n_t,
ig = res$best_ig,
right = generate_node(dat[idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression),
left = generate_node(dat[!idx, ], depth = depth + 1, max_depth = max_depth, min_n = min_n, min_ig = min_ig, metric_func = metric_func, is_regression = is_regression)
)
fi <- (n_t/N) * (res$best_ig - nrow(dat[idx, ])/n_t * output$right$ig - nrow(dat[!idx, ])/n_t * output$left$ig)
df_fi[df_fi$name == res$var, 2] <<- df_fi[df_fi$name == res$var, 2] + fi
return(output)
}
}
} else {
return(list(
depth = depth,
pos = "leaf",
n = nrow(dat),
ig = ifelse(is.null(res$best_ig), 0, res$best_ig),
pred = ifelse(is_regression, mean(y), mode_y)
))
# ----
}
}
}
}
hasil <- decision_tree(
species ~ .,
data = iris,
metric_func = "gini impurity",
max_depth = 3,
min_n = 20,
min_ig = 1e-3
)
df_fi
df_fi %>%
group_by(name) %>%
summarise_all(sum) %>%
mutate(norm_fi = fi/sum(fi))
dat <- read.csv('D:/__Datasets/ml/califorania_housing.csv')
head(dat)
dat %>%
select(-c('X', 'Latitude', 'Longitude', 'Population'))
dat <- dat %>%
select(-c('X', 'Latitude', 'Longitude', 'Population'))
head(dat)
hasil2 <- decision_tree(
price ~ .,
data = dat,
metric_func = "variance",
max_depth = 3,
min_n = 4,
min_ig = 1e-3
)
names(dat)
names(dat[-price])
dat[-'price']
names(dat)[-"price"]
df_fi <- data.frame(name = names(dat[-6]), fi = 0)
df_fi
hasil2 <- decision_tree(
price ~ .,
data = dat,
metric_func = "variance",
max_depth = 3,
min_n = 4,
min_ig = 1e-3
)
df_fi
df_fi
df_fi %>%
group_by(name) %>%
summarise_all(sum) %>%
mutate(norm_fi = fi/sum(fi))
df_fi <- data.frame(name = names(dat[-6]), fi = 0)
df_fi
hasil2 <- decision_tree(
price ~ .,
data = dat,
metric_func = "variance",
max_depth = 3,
min_n = 2,
min_ig = 1e-3
)
df_fi
df_fi %>%
group_by(name) %>%
summarise_all(sum) %>%
mutate(norm_fi = fi/sum(fi))
hasil_rpart <- rpart::rpart(price ~ ., data = dat, maxdepth = 3, minbucket = 20, minsplit = 2, cp = 1e-9)
hasil_rpart$variable.importance
scale(hasil_rpart$variable.importance)
df_fi %>%
group_by(name) %>%
summarise_all(sum) %>%
mutate(norm_fi = fi/sum(fi))
print(hasil2)
str(hasil2)
